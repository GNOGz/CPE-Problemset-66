#include <iostream>
using namespace std;

int greatDivior (int n){
    // Goal -> หาจำนวนเต็ม i ที่มากที่สุดที่ n หาร i ลงตัว โดยเลขที่ i ต้องน้อยกว่า n ด้วย คุ้นๆเหมือน ex2
    // Concept copy paste จากข้อเดิม
    // ในเมื่อเราหาเลขที่ มาก ที่สุดที่น้อยกว่า n ที่ n หารลงตัว เราก็เริ่มที่เลขที่น้อยกว่า n ก็คือ i = n - 1 ซึ่งน้อยกว่า n และมากสุดเท่าที่เป็นไปได้

    int i = n-1;

    // copy n paste
    // ต่อไปเราก็ต้องเช็คว่า n / i ลงตัวไหม หารลงตัวแปลว่า หารแล้วต้องไม่มีเศษ
    // ในภาษา c++ ก็คือ n % i ต้องได้ 0    <--------------------------  
    // โดย ถ้าเกิดหารไม่ลงตัว n % i ไม่เท่ากับ 0 เราก็ต้องหา i ตัวใหม่       ^
    // เราก็เลยจะลด i ลง 1 แล้วก็กลับไปลองหารใหม่  -------------------^ 
    // โดยเราสามารถลูปไปเลยๆจนเจอ i ที่ n / i ลงได้ได้เลยโดยใช้ while(true) ซึ่งจะลูปไม่หยุด
    // แต่ถ้าดูในทางคณิตศาสต์ ถ้า i ลดลงจนเท่ากับ n ยังไง n / i ก็จะเท่ากับ n / 1 ซึ่งลงตัวแน่ๆ
    // แปลว่าเราสามารถลูปได้เรื่อยๆถ้า i มีค่ามากกว่า 1 ซึ่งก็คือ i > 1 หรือ i >= 1 ก็ได้เหมือนกัน (ขอไม่อธิบาย ง่วงแล้ว) 

    while ( i > 1){
        if (n%i == 0){
            break; // < ไหนๆก็มาแล้วลองดู break สักหน่อย หน้าที่ของมันคือ หยุดการทำงานในลูปทันที
                   //   ไม่ว่า while หรือ เงื่อนไขใน ( ) ของ while จะใหญ่มาจากไหน break เทพกว่า
                   //   เจอ break = หยุดทันที ดังนั้นถ้าเจอ break ก็จะข้ามมาที่ --v 
        }          //                                                   v
    i--;           //                                                   v
    }              //  <------------------------------------------------- บรรทัดนี้เลย

    return i;      // <  รีเทิร์น i ได้เลย
}

// ต่อไปถ้าจะ optimize ก็ทำได้เหมือน ex2 เลยลองเอาไปฝึกเล่นๆได้แต่มีวิธีที่ง่ายกว่านั้น ʕ•́ᴥ•̀ʔっ♡ 
// จริงเราเขียนโค้ดแค่ ex2 แล้วใช้เวทมนตร์ที่เรียกว่า คณิตศาสตร์นิดหน่อยก็จะได้ว่า
// มันคือ ฟังก์ชั่นใน ex2 เลยแค่ แก้ return นิดหน่อย
int findDivisor4withMagic2Tranform2GreatDivisor(int n){
    if(n % 2 == 0) return n / 2;

    int i = 3; 
    while(i * i <= n){
        if(n % i == 0) return n / i;    
        i += 2;                     
    }
    return 1; // มันคือ n / n แต่มัน = 1
}
//Concept ของโค้ด(จริงๆของคณิต) คือ Concept ที่ copy paste มาจาก ex2 
//   คือ ยังไงเลข i ที่หาร n ลงตัวจะมีคู่ k ของมันที่ i * k = n อยู่
//   ลองดูคู่ i k ของเลข n = 24   ของ n = 16    n = 21     n = 49    n = 13             
//   1 * 24                      1 * 16      1 * 21      1 * 49    1 * 13
//   2 * 12                      2 * 8       3 * 7       7 * 7 
//   3 * 8                       4 * 4
//   4 * 6
// ซึ่งเลข k ที่มากที่สุด(ที่ไม่ใช่ n) ที่ n / k ลงตัวจะคู่กับเลข i ที่น้อยที่สุดที่ n / i ลงตัวเช่นกัน
// ดังนั้น i * k = n จะได้ว่า k = n / i จบ

int main (){
    cout << greatDivior(2465857) << endl;
    cout << findDivisor4withMagic2Tranform2GreatDivisor(2465857) << endl;
    return 0;
}
